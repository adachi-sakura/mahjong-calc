<html>
    <head>
        <h1>Mahjong Calculator</h1>
    </head>
    <body>
        <div id="app">
            <h1>手牌：{{ tehai }}</h1>
            <h1>已用牌：{{ used }}</h1>
            <h1>副露: {{ fuuro }}</h1>
            <h1>面子: {{ menzu }}</h1>
        </div>
    </body>
</html>


<script src="https://unpkg.com/vue"></script>
<script src="https://unpkg.com/lodash"></script>

<script>
    const type2size = {
        "m": 9, //m for man
        "p": 9, //p for pin
        "s": 9, //s for so
        "f": 4, //f for fu
        "y": 3, //y for yaku
    }
    const type2base = {
        "m": 0,
        "p": 1,
        "s": 2,
        "f": 3,
        "y": 4,
    }
    function Card(val, type) {
        console.assert(type2size.hasOwnProperty(type), "type invalid");
        console.assert(type != "f" && type != "y" || val != 0, "aka invalid");
        console.assert(val >= 0 && val <= type2size[type], "value invalid");
        this.value = val == 0 ? 5:val;
        this.type = type;
        this.aka = val == 0 ? true:false;
        this.score = type2base[this.type]*10+this.value;
    }
    Card.prototype.name = function() {
        if (this.aka == true) {
            return "0"+this.type;
        }
        return this.value + this.type;
    }

    function Menzu() {
        this.shunzi = false;
        this.kezi = false;
        this.ura = false;
        this.type = "";
        this.cards = [];
    }

    Menzu.prototype.generate = function(isUra) {
        this.ura = isUra;
        this.shunzi = Shunzi(this.cards);
        this.kezi = Kezi(this.cards);
        if(!this.shunzi && !this.kezi) {
            throw "generation failed";
        }
        this.type = this.cards[0].type;
    }

    function Tokuten(fan, fu, isYakuman, isOya, isTsumo) {
        this.fan = fan;
        this.fu = fu;
        this.isYakuman = isYakuman;
        this.isOya = isOya;
    }

    function Yaku(name, fan, kuisagari, isYakuman, checkFunc) {
        this.name = name;
        this.fan = fan;
        this.kuisagari = kuisagari;
        this.isYakuman = isYakuman;
        this.check = checkFunc;
    }

    function Name(val, type) {
        return val+type;
    }

    function Kezi(menzu) {
        var len = menzu.length;
        if (len < 3 || len > 4) {
            return false;
        }
        for(let i=1, pre=menzu[i-1], cur=menzu[i];
             i<len;
             i++, pre=menzu[i-1], cur=menzu[i]) {
                if(pre.score != cur.score) {
                    return false;
                }
        }
        return true;
    }
    
    //should be sorted
    function Shunzi(menzu) {
        var len = menzu.length;
        if (len!= 3) {
            return false;
        }
        for (let i = 1, pre = menzu[i - 1], cur = menzu[i];
            i < len;
            i++ , pre = menzu[i - 1], cur = menzu[i]) {
            if (pre.type != cur.type || pre.value+1 != cur.value) {
                return false;
            }
        }
        return true;
    }

    function IsDora(target, indicate) {
        if(indicate.type != target.type) {
            return false;
        }
        return indicate.value%type2size[indicate.type]+1 == target.value;
    }

    function IsCharacterCard(card) {
        return card.type == "f" || card.type == "y";
    }

    function IsCharacterType(type) {
        return type == "f" || type == "y";
    }

    function Is19(card) {
        return (card.value == 1 || card.value == 9) && !IsCharacterCard(card);
    }

    function Dora(indicate) {
        return new Card(indicate.value%type2size[indicate.type]+1, indicate.type);
    }

    function CalcDoraCount(cardArr, doraScores) {
        var total = 0;
        for (let card in doraScores) {
            if (doraScores[card.score]) {
                total += doraScores[card.score];
            }
        }
    }

    var app = new Vue({
        el: "#app",
        data: {
            cardInstances: {},
            dora: [],
            ura: [],
            used: {},
            akaUsed: {
                "m": false,
                "s": false,
                "p": false,
            },
            normalYakus: [],
            yakumanYakus: [],
            tehai: [],
            fuuro: [],
            ps: [],
            ms: [],
            ss: [],
            fs: [],
            ys: [],
            menzu: new Menzu(),
            menzen: false,

            jifu: null,
            jofu: null,

            tsumo: false,
            riichi: false,
            wriichi: false,
            ippatsu: false,
            chankan: false,
            haitei: false,
            hotei: false,
            tianho: false,
            chiho: false,

        },
        created: function() {
            for (let type in type2size) {
                if (!IsCharacterType(type)) {
                    let instance = new Card(0, type);
                    this.cardInstances[instance.name()] = instance;
                }
                let size = type2size[type];
                for(let val=1; val<=size; val++) {
                    let instance = new Card(val, type);
                    this.cardInstances[instance.name()] = instance;
                }
            }
        },
        computed: {
            sortedTehai: function() {

            },

        },
        watch: {
            fuuro: function(newFuroo, oldFuroo) {
                this.menzen = this.isMenzen();
            }
        },
        methods: {
            classify: function() {
                this.ps = [];
                this.ms = [];
                this.ss = [];
                this.fs = [];
                this.ys = [];
                this.tehai.forEach(card => {
                    switch(card.type) {
                        case "p":
                            this.ps.push(card);
                            break;
                        case "m":
                            this.ms.push(card);
                            break;
                        case "s":
                            this.ss.push(card);
                            break;
                        case "f":
                            this.fs.push(card);
                            break;
                        case "y":
                            this.ys.push(card);
                            break;
                        default:
                            throw("Unknown type: "+card.type);
                    }
                });
            },

            onClick: function(card, destArr) {                
                if (!this.checkUsed(card)) {
                    alert("超出4张");
                    return;
                }
                if (!this.checkAkaUsed(card)) {
                    alert("红宝牌已使用")
                    return;
                }
                if (!this.checkCardsNum()) {
                    alert("手牌数量超出上限");
                    return;
                }
                this.insertCard(card, destArr);
                this.afterInsert(card);
            },

            afterInsert: function(card) {
                var score = card.score;
                if (card.aka == true) {
                    this.akaUsed[card.type] = true;
                }
                this.used[score] = this.used[score]? this.used[score]+1 : 1;
            },

            checkCardsNum: function() {
                return this.tehai.length+this.fuuro.length*3 <= 14;
            },

            checkNewFuuroAvailable: function() {
                return this.tehai.length+(this.fuuro.length+1)*3 <= 14;
            },

            checkUsed: function(card) {
                var score = card.score;
                return this.used[score] <= 4;
            },

            checkAkaUsed: function(card) {
                return card.aka == false || this.akaUsed[card.type] == true;
            },

            insertCard: function(card, destArr) {
                for(var i = 0, len = destArr.length; i<len; i++) {
                    if (destArr[i].score >= card.score) {
                        break;
                    }
                }
                destArr.splice(i, 0, card);
            },

            insertMenzu: function(isUraKan) {
                try {
                    this.menzu.generate(isUraKan);
                }
                catch (err) {
                    alert("面子非法");
                    return;
                }
                if (!this.checkNewFuuroAvailable()) {
                    alert("牌数已达上限，无法加入新副露");
                    return;
                }
                this.fuuro.push(this.menzu);
                this.menzu = new Menzu;
            },

            doraCount: function(indicateArr) {
                var doraScores = this.getDoraCardScores(indicateArr);
                var total = 0;
                total += CalcDoraCount(this.tehai, doraScores);
                for(let menzu in this.fuuro) {
                    total += CalcDoraCount(menzu, this.fuuro);
                }
                return total;
            },     

            getDoraCardScores: function(indicates) {
                var targetCards = {};
                for(let indicate in indicates) {
                    let score = Dora(inidcate).score;
                    targetCards[score] = targetCards[score] ? targetCards[score]+1:0;
                }
                return targetCards;
            },

            akaCount: function() {
                var sum = 0;
                for(let key in this.akaUsed) {
                    if (this.akaUsed[key])
                        sum++;
                }                
                return sum;
            },

            isMenzen: function() {
                if (this.fuuro.length == 0) {
                    return true;
                }
                this.fuuro.forEach(menzu => {
                    if (menzu.ura == false) {
                        return false;
                    }
                });
                return true;
            },

            checkYakus: function() {
                this.classify();
                yakus = [];
                var yakuCheckFunc = yaku => {
                    if (yaku.check(this)) {
                        yakus.push(yaku);
                    }
                };
                try {
                    this.yakumanYakus.forEach(yakuCheckFunc);
                }
                catch (err) {
                    alert(err);
                    return;
                }                
                if (yakus.length != 0) {
                    return yakus;
                }
                try {
                    this.normalYakus.forEach(yakuCheckFunc);
                }
                catch (err) {
                    alert(err);
                    return;
                }
                
                return yakus;
            }

        }
    })

    function checkRiichiYaku(ctx) {
        if (!ctx.riichi) {
            return false;
        }
        if (ctx.menzen) {
            throw("必须在门清状态下立直");
        }
        if (ctx.wriichi) {
            throw("无法与双立直同时生效");
        }

        return true;
    }

    function checkIppatsuYaku(ctx) {
        if (!ctx.ippatsu) {
            return false;
        }
        if (!ctx.riichi && !ctx.wriichi) {
            throw("一发必须复合立直");
        }
        return true;
    }

    function checkMenzenTsumoYaku(ctx) {
        return ctx.menzen && ctx.tsumo;
    }

    function checkPinhoYaku(ctx) {

    }

    function checkTanyaoYaku(ctx) {
        var checkFunc = card => {
            if (IsCharacterCard(card) || Is19(card)) {
                return false;
            }
        };

        for(let menzu in ctx.fuuro) {
            for(let card in menzu) {
                if (!checkFunc(card)) {
                    return false;
                }
            }
        }
        for(let card in ctx.tehai) {
            if(!checkFunc(card)) {
                return false;
            }
        }
        return true;
    }

    function checkWRiichiYaku(ctx) {
        if (!ctx.wriichi) {
            return false;
        }
        if (ctx.menzen) {
            throw ("必须在门清状态下双立直");
        }
        if (ctx.riichi) {
            throw ("无法与立直同时生效");
        }

        return true;
    }
    
    function checkHaiteiYaku(ctx) {
        if (!ctx.haitei) {
            return false;
        }
        if (!ctx.tsumo) {
            throw("海底必须自摸");
        }
        return true;
    }

    function checkHoteiYaku(ctx) {
        if (!ctx.hotei) {
            return false;
        }
        if (ctx.tsumo) {
            throw("河底无法自摸");
        }
        if (ctx.ippatsu) {
            throw("河底无法复合一发");
        }
        return true;
    }

    function checkChankanYaku(ctx) {
        if (!ctx.chankan) {
            return false;
        }
        if (ctx.tsumo) {
            throw("抢杠无法自摸");
        }
        return true;
    }

</script>