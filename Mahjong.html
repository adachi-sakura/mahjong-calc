<html>
  <head>
    <h1>Mahjong Calculator</h1>
  </head>
  <body>
    <div id="app">
      <h1>手牌：{{ tehai }}</h1>
      <h1>已用牌：{{ used }}</h1>
      <h1>副露: {{ fuuro }}</h1>
      <h1>面子: {{ menzu }}</h1>
    </div>
  </body>
</html>

<script src="https://unpkg.com/vue"></script>
<script src="https://unpkg.com/lodash"></script>

<script>
  const type2size = {
    m: 9, //m for man
    p: 9, //p for pin
    s: 9, //s for so
    f: 4, //f for fu
    y: 3, //y for yaku
  }
  const type2base = {
    m: 0,
    p: 1,
    s: 2,
    f: 3,
    y: 4,
  }

  const AgariType = {
    LiangMian: 0,
    QianZhang: 1,
    BianZhang: 2,
    DuiPeng: 3,
    DanQi: 4,
    Unknown: 5,
  }

  function Card(val, type) {
    'use strict'
    console.assert(type2size.hasOwnProperty(type), 'type invalid')
    console.assert((type != 'f' && type != 'y') || val != 0, 'aka invalid')
    console.assert(val >= 0 && val <= type2size[type], 'value invalid')
    this.value = val === 0 ? 5 : val
    this.type = type
    this.aka = val === 0 ? true : false
    this.score = type2base[this.type] * 10 + this.value
  }

  Card.prototype.name = function () {
    if (this.aka === true) {
      return '0' + this.type
    }
    return this.value + this.type
  }

  Card.prototype.equal = function (card) {
    return card && this.score === card.score
  }

  Card.prototype.IsPrev = function (card) {
    return card && this.type === card.type && this.value + 1 === card.value
  }

  Card.prototype.IsNext = function (card) {
    return card && this.type === card.type && this.value - 1 === card.value
  }

  function Menzu() {
    'use strict'
    this.shunzi = false
    this.kezi = false
    this.duizi = false
    this.ura = false
    this.type = ''
    this.cards = []
  }

  Menzu.prototype.generate = function (isUra) {
    this.ura = isUra
    this.shunzi = Shunzi(this.cards)
    this.kezi = Kezi(this.cards)
    this.duizi = Duizi(this.cards)
    if (!this.shunzi && !this.kezi && !this.duizi) {
      throw 'generation failed'
    }
    this.type = this.cards[0].type
  }

  Menzu.prototype.toString = function () {
    var ret = ''
    this.cards.forEach((card) => (ret += card.score.toString()))
    return ret
  }

  Menzu.prototype.has = function (target) {
    for (let card of this.cards) {
      if (card.equal(target)) {
        return true
      }
    }
    return false
  }

  Menzu.prototype.nonTypeString = function () {
    var ret = ''
    this.cards.forEach((card) => (ret += card.value.toString()))
    return ret
  }

  Menzu.Instance = function (cards) {
    var instance = new Menzu()
    instance.cards = cards
    instance.generate(true)

    return instance
  }

  function Tokuten(fan, fu, isYakuman, isOya, isTsumo) {
    'use strict'
    this.fan = fan
    this.fu = fu
    this.isYakuman = isYakuman
    this.isOya = isOya
  }

  function Yaku(name, fan, kuisagari, isYakuman, checkFunc) {
    this.name = name
    this.fan = fan
    this.kuisagari = kuisagari
    this.isYakuman = isYakuman
    this.check = checkFunc
  }

  function Composition() {
    'use strict'
    this.menzus = []
    this.duizis = []
    this.lastDazi = null
  }

  Composition.prototype.Lint = function (fuuro, isTsumo) {
    this.menzus = this.menzus.concat(fuuro)
    this.lastDazi.ura = isTsumo
  }

  function Name(val, type) {
    return val + type
  }

  function Kezi(menzu) {
    var len = menzu.length
    if (len < 3 || len > 4) {
      return false
    }
    for (
      let i = 1, pre = menzu[i - 1], cur = menzu[i];
      i < len;
      i++, pre = menzu[i - 1], cur = menzu[i]
    ) {
      if (pre.score != cur.score) {
        return false
      }
    }
    return true
  }

  //should be sorted
  function Shunzi(menzu) {
    var len = menzu.length
    if (len != 3) {
      return false
    }
    for (
      let i = 1, pre = menzu[i - 1], cur = menzu[i];
      i < len;
      i++, pre = menzu[i - 1], cur = menzu[i]
    ) {
      if (pre.type != cur.type || pre.value + 1 != cur.value) {
        return false
      }
    }
    return true
  }

  function Duizi(dazi) {
    var len = dazi.length
    if (len != 2) {
      return false
    }

    return dazi[0].equal(dazi[1])
  }

  //sorted need
  function JudgeAgariType(lastDazi, agari) {
    var judgeFuncs = [
      JudgeShunziAgariType,
      JudgeKeziAgariType,
      JudgeDuiziAgariType,
    ]
    for (let judgeFunc of judgeFuncs) {
      let type = judgeFunc(lastDazi, agari)
      if (type !== AgariType.Unknown) {
        return type
      }
    }
    return AgariType.Unknown
  }

  function JudgeShunziAgariType(lastDazi, agari) {
    if (!lastDazi.shunzi) {
      return AgariType.Unknown
    }
    var cards = lastDazi.cards
    if (cards[1].equal(agari)) {
      return AgariType.QianZhang
    } else if (
      (_.first(cards).value =
        (1 && _.last(cards).equal(agari)) ||
        (_.last(cards).value === type2size[_.last(cards).type] &&
          _.first(cards).equal(agari)))
    ) {
      return AgariType.DanBian
    } else if (_.first(cards).equal(agari) || _.last(cards).equal(agari)) {
      return AgariType.LiangMian
    }
    return AgariType.Unknown
  }

  function JudgeKeziAgariType(lastDazi, agari) {
    if (!lastDazi.kezi) {
      return AgariType.Unknown
    }
    var cards = lastDazi.cards
    if (_.first(cards).equal(agari)) {
      return AgariType.DuiPeng
    }
    return AgariType.Unknown
  }

  function JudgeDuiziAgariType(lastDazi, agari) {
    if (!lastDazi.duizi) {
      return AgariType.Unknown
    }
    var cards = lastDazi.cards
    if (_.first(cards).equal(agari)) {
      return AgariType.DanQi
    }
    return AgariType.Unknown
  }

  function InsertCard(card, destArr) {
    for (var i = 0, len = destArr.length; i < len; i++) {
      if (destArr[i].score >= card.score) {
        break
      }
    }
    destArr.splice(i, 0, card)
  }

  function GenerateCompositions(tehai, agariCard) {
    var cards = _.clone(tehai)
    InsertCard(agariCard, cards)
    var countDict = {}
    for (let card of cards) {
      countDict[card.score] = countDict[card.score]
        ? countDict[card.score] + 1
        : 1
    }
    var usedDict = {}
    for (let key in countDict) {
      usedDict[key] = 0
    }

    var data = {
      cards: cards,
      agariCard: agariCard,
      countDict: countDict,
    }
    var ctx = {
      //cur: 0,
      cardsRemain: _.cloneDeep(cards),
      composition: new Composition(),
      usedDict: usedDict,
    }
    return ParseToComposition(ctx, data)
  }

  function ParseToComposition(ctx, data) {
    // console.assert(ctx.cur <= data.cards.length, 'ctx cur invalid')
    if (ctx.cardsRemain.length === 0) {
      return [ctx.composition]
    }
    var funcs = [ParseFirstKezi, ParseFirstShunzi, ParseFirstDuizi]
    var comps = []
    for (let parseFunc of funcs) {
      let newDazi = parseFunc(ctx.cardsRemain)
      if (newDazi == null) {
        continue
      }
      let newCtxs = CreateNewParseCtx(ctx, data, newDazi)
      newCtxs.forEach(
        (newCtx) => (comps = comps.concat(ParseToComposition(newCtx, data)))
      )
    }
    return comps
  }

  function CreateNewParseCtx(ctx, data, newDazi) {
    var newCtxs = []
    var newCtx = _.cloneDeep(ctx)

    var map = new Map()
    for (let card of newDazi.cards) {
      let score = card.score
      map.set(score, map.has(score) ? map.get(score) + 1 : 1)
    }

    _.remove(newCtx.cardsRemain, function (card) {
      if (map.get(card.score)) {
        let cnt = map.get(card.score) - 1
        map.set(card.score, cnt === 0 ? undefined : cnt)
        return true
      }
      return false
    })

    newDazi.cards.forEach((card) => newCtx.usedDict[card.score]++)
    //newCtx.cur = NewPosition(newCtx, data, newDazi)
    var compositions = NewCompositions(newCtx, data, newDazi)
    for (let comp of compositions) {
      let c = _.cloneDeep(newCtx)
      c.composition = comp
      newCtxs.push(c)
    }
    return newCtxs
  }

  function NewCompositions(ctx, data, newDazi) {
    console.assert(newDazi.cards.length === 2 || newDazi.cards.length === 3)
    var comp = ctx.composition
    switch (newDazi.cards.length) {
      case 3:
        comp.menzus.push(newDazi)
        break
      case 2:
        comp.duizis.push(newDazi)
        break
    }
    if (
      comp.lastDazi != null ||
      newDazi.cards.find((elem) => elem.score === data.agariCard.score) ==
        undefined
    ) {
      return [comp]
    }
    if (
      ctx.usedDict[data.agariCard.score] ===
      data.countDict[data.agariCard.score]
    ) {
      comp.lastDazi = newDazi
      return [comp]
    }
    var comp2 = _.cloneDeep(comp)
    comp.lastDazi = newDazi
    return [comp, comp2]
  }

  function FilterCompositions(comps) {
    comps.forEach((comp) => {
      comp.menzus.sort()
      comp.duizis.sort()
    })

    var set = new Set()
    _.remove(comps, function (comp) {
      let json = JSON.stringify(comp)
      if (set.has(json)) {
        return true
      }
      set.add(json)
      return false
    })
  }

  //   function NewPosition(ctx, data, newDazi) {
  //     console.assert(newDazi.length === 2 || newDazi.length === 3)
  //     var curCard = data.cards[ctx.cur]
  //     var newPos = ctx.cur
  //     if (newDazi.length === 2) {
  //       newPos += 2
  //     } else {
  //       if (newDazi[1].score === curCard.score) {
  //         newPos += 3
  //       } else {
  //         newPos += 1
  //       }
  //     }
  //     if (ctx.usedDict[curCard.score] < data.countDict[curCard.score]) {
  //       return newPos
  //     }
  //     while (newPos < data.cards.length) {
  //       let card = data.cards[newPos]
  //       newPos += ctx.usedDict[card.score]
  //       if (ctx.usedDict[card.score] < data.countDict[card.score]) {
  //         break
  //       }
  //     }
  //     return newPos
  //   }

  function CardsStatus(cards, tempCur = 0) {
    this.cards = cards
    this.tempCur = Math.min(tempCur, this.cards.length)
  }

  CardsStatus.prototype.Card = function () {
    if (this.tempCur >= this.cards.length) {
      return null
    }
    return this.cards[this.tempCur]
  }

  CardsStatus.prototype.at = function (idx) {
    if (idx >= this.cards.length) {
      return null
    }
    return this.cards[idx]
  }

  CardsStatus.prototype.Next = function () {
    return new CardsStatus(this.cards, this.tempCur + 1)
  }

  CardsStatus.prototype.NextDifferent = function () {
    var cur = this.tempCur
    var anchor = this.Card()
    while (cur < this.cards.length && anchor.equal(this.at(cur))) {
      cur++
    }
    return new CardsStatus(this.cards, cur)
  }

  function ParseFirstKezi(cardsRemain) {
    // try {
    //   if (
    //     data.cards[ctx.cur].equal(data.cards[ctx.cur + 1]) &&
    //     data.cards[ctx.cur].equal(data.cards[ctx.cur + 2])
    //   ) {
    //     keziCards.push(data.cards[ctx.cur])
    //     keziCards.push(data.cards[ctx.cur + 1])
    //     keziCards.push(data.cards[ctx.cur + 2])
    //   }
    // } catch (err) {
    // } finally {
    //   return keziCards
    // }
    var status = new CardsStatus(cardsRemain)
    var nStatus = status.Next()
    var nnStatus = nStatus.Next()
    var [curCard, nCard, nnCard] = [
      status.Card(),
      nStatus.Card(),
      nnStatus.Card(),
    ]
    if (curCard && curCard.equal(nCard) && nCard.equal(nnCard)) {
      return Menzu.Instance([curCard, nCard, nnCard])
    }
    return null
  }

  function ParseFirstShunzi(cardsRemain) {
    // var shunziCards = []
    // var preCard = data.cards[ctx.cur]
    // shunziCards.push(preCard)
    // for (let pos = ctx.cur + 1; pos < data.cards.length; pos++) {
    //   let curCard = data.cards[pos]
    //   if (curCard.type != preCard.type) {
    //     return []
    //   }
    //   if (curCard.value === preCard.value + 1) {
    //     shunziCards.push(curCard)
    //     if (shunziCards.length === 3) {
    //       return shunziCards
    //     }
    //     preCard = curCard
    //   }
    // }
    var status = new CardsStatus(cardsRemain)
    var nStatus = status.NextDifferent()
    var nnStatus = nStatus.NextDifferent()
    var [curCard, nCard, nnCard] = [
      status.Card(),
      nStatus.Card(),
      nnStatus.Card(),
    ]
    if (curCard && curCard.IsPrev(nCard) && nCard.IsPrev(nnCard)) {
      return Menzu.Instance([curCard, nCard, nnCard])
    }
    return null
  }

  function ParseFirstDuizi(cardsRemain) {
    // var duiziCards = []
    // try {
    //   if (data.cards[ctx.cur].equal(data.cards[ctx.cur + 1])) {
    //     duiziCards.push(data.cards[ctx.cur])
    //     duiziCards.push(data.cards[ctx.cur + 1])
    //   }
    // } catch (err) {
    // } finally {
    //   return duiziCards
    // }
    var status = new CardsStatus(cardsRemain)
    var nStatus = status.Next()
    var [curCard, nCard] = [status.Card(), nStatus.Card()]
    if (curCard && curCard.equal(nCard)) {
      return Menzu.Instance([curCard, nCard])
    }
    return null
  }

  function IsDora(target, indicate) {
    if (indicate.type != target.type) {
      return false
    }
    return (indicate.value % type2size[indicate.type]) + 1 === target.value
  }

  function IsCharacterCard(card) {
    return card.type === 'f' || card.type === 'y'
  }

  function IsCharacterType(type) {
    return type === 'f' || type === 'y'
  }

  function Is19(card) {
    return (card.value === 1 || card.value === 9) && !IsCharacterCard(card)
  }

  function Dora(indicate) {
    return new Card(
      (indicate.value % type2size[indicate.type]) + 1,
      indicate.type
    )
  }

  function CalcDoraCount(cardArr, doraScores) {
    var total = 0
    for (let card of cardArr) {
      if (doraScores[card.score]) {
        total += doraScores[card.score]
      }
    }
    return total
  }

  var app = new Vue({
    el: '#app',
    data: {
      cardInstances: {},
      dora: [],
      ura: [],
      used: {},
      akaUsed: {
        m: false,
        s: false,
        p: false,
      },
      normalYakus: [],
      yakumanYakus: [],
      tehai: [],
      fuuro: [],
      agariCard: {},
      ps: [],
      ms: [],
      ss: [],
      fs: [],
      ys: [],
      compostions: [],
      menzu: new Menzu(),
      menzen: false,

      jifu: null,
      jofu: null,

      tsumo: false,
      riichi: false,
      wriichi: false,
      ippatsu: false,
      chankan: false,
      haitei: false,
      hotei: false,
      tenho: false,
      chiho: false,
    },
    created: function () {
      for (let type in type2size) {
        if (!IsCharacterType(type)) {
          let instance = new Card(0, type)
          this.cardInstances[instance.name()] = instance
        }
        let size = type2size[type]
        for (let val = 1; val <= size; val++) {
          let instance = new Card(val, type)
          this.cardInstances[instance.name()] = instance
        }
      }
    },
    computed: {
      sortedTehai: function () {},
    },
    watch: {
      fuuro: function (newFuroo, oldFuroo) {
        this.menzen = this.isMenzen()
      },
    },
    methods: {
      classify: function () {
        this.ps = []
        this.ms = []
        this.ss = []
        this.fs = []
        this.ys = []
        this.tehai.forEach((card) => {
          switch (card.type) {
            case 'p':
              this.ps.push(card)
              break
            case 'm':
              this.ms.push(card)
              break
            case 's':
              this.ss.push(card)
              break
            case 'f':
              this.fs.push(card)
              break
            case 'y':
              this.ys.push(card)
              break
            default:
              throw 'Unknown type: ' + card.type
          }
        })
      },

      onClick: function (card, destArr) {
        if (!this.checkUsed(card)) {
          alert('超出4张')
          return
        }
        if (!this.checkAkaUsed(card)) {
          alert('红宝牌已使用')
          return
        }
        if (!this.checkCardsNum()) {
          alert('手牌数量超出上限')
          return
        }
        InsertCard(card, destArr)
        this.afterInsert(card)
      },

      afterInsert: function (card) {
        var score = card.score
        if (card.aka === true) {
          this.akaUsed[card.type] = true
        }
        this.used[score] = this.used[score] ? this.used[score] + 1 : 1
      },

      checkCardsNum: function () {
        return this.tehai.length + this.fuuro.length * 3 <= 13
      },

      checkNewFuuroAvailable: function () {
        return this.tehai.length + (this.fuuro.length + 1) * 3 <= 13
      },

      checkUsed: function (card) {
        var score = card.score
        return this.used[score] <= 4
      },

      checkAkaUsed: function (card) {
        return card.aka === false || this.akaUsed[card.type] === true
      },

      insertMenzu: function (isUraKan) {
        try {
          this.menzu.generate(isUraKan)
        } catch (err) {
          alert('面子非法')
          return
        }
        if (!this.checkNewFuuroAvailable()) {
          alert('牌数已达上限，无法加入新副露')
          return
        }
        this.fuuro.push(this.menzu)
        this.menzu = new Menzu()
      },

      doraCount: function (indicateArr) {
        var doraScores = this.getDoraCardScores(indicateArr)
        var total = 0
        total += CalcDoraCount(this.tehai, doraScores)
        for (let menzu of this.fuuro) {
          total += CalcDoraCount(menzu, this.fuuro)
        }
        return total
      },

      getDoraCardScores: function (indicates) {
        var targetCards = {}
        for (let indicate of indicates) {
          let score = Dora(inidcate).score
          targetCards[score] = targetCards[score] ? targetCards[score] + 1 : 0
        }
        return targetCards
      },

      akaCount: function () {
        var sum = 0
        for (let key in this.akaUsed) {
          if (this.akaUsed[key]) sum++
        }
        return sum
      },

      isMenzen: function () {
        if (this.fuuro.length === 0) {
          return true
        }
        for (let menzu of this.fuuro) {
          if (menzu.ura === false) {
            return false
          }
        }

        return true
      },

      parse: function () {
        this.classify()
        this.compositions = GenerateCompositions(this.tehai, this.agariCard)
      },

      checkYakus: function () {
        yakus = []
        var yakuCheckFunc = (yaku) => {
          if (yaku.check(this)) {
            yakus.push(yaku)
          }
        }
        try {
          this.yakumanYakus.forEach(yakuCheckFunc)
        } catch (err) {
          alert(err)
          return
        }
        if (yakus.length != 0) {
          return yakus
        }
        try {
          this.normalYakus.forEach(yakuCheckFunc)
        } catch (err) {
          alert(err)
          return
        }

        return yakus
      },

      testCardsArr: function () {
        var arr = [
          '1s',
          '1s',
          '1s',
          '2s',
          '3s',
          '4s',
          '5s',
          '6s',
          '7s',
          '8s',
          '9s',
          '9s',
          '9s',
        ]
        var cards = []
        arr.forEach((name) => cards.push(this.cardInstances[name]))
        return cards
      },

      testParse: function () {
        var agari = '3s'
        var agariCard = this.cardInstances[agari]
        var cards = this.testCardsArr()
        var res = GenerateCompositions(cards, agariCard)
        var fun = function (arr) {
          let str = ''
          for (let elem of arr) {
            str += elem.name()
          }
          return str
        }
        for (let comp of res) {
          for (let mz of comp.menzus) {
            console.log(fun(mz.cards))
          }
          for (let dz of comp.duizis) {
            console.log(fun(dz.cards))
          }
          console.log('last dazi: ' + fun(comp.lastDazi.cards))
          console.log(JudgeAgariType(comp.lastDazi, agariCard))
        }
        return res
        //console.log(JSON.stringify(res, null , '\t'));
      },
    },
  })

  function checkRiichiYaku(ctx) {
    if (!ctx.riichi) {
      return false
    }
    if (ctx.menzen) {
      throw '必须在门清状态下立直'
    }
    if (ctx.wriichi) {
      throw '无法与双立直同时生效'
    }

    return true
  }

  function checkIppatsuYaku(ctx) {
    if (!ctx.ippatsu) {
      return false
    }
    if (!ctx.riichi && !ctx.wriichi) {
      throw '一发必须复合立直'
    }
    return true
  }

  function checkMenzenTsumoYaku(ctx) {
    return ctx.menzen && ctx.tsumo
  }

  function checkPinhoYaku(ctx, comp) {}

  function checkTanyaoYaku(ctx) {
    var checkFunc = (card) => {
      if (IsCharacterCard(card) || Is19(card)) {
        return false
      }
    }

    for (let menzu of ctx.fuuro) {
      for (let card of menzu) {
        if (!checkFunc(card)) {
          return false
        }
      }
    }
    for (let card of ctx.tehai) {
      if (!checkFunc(card)) {
        return false
      }
    }
    return true
  }

  function checkWRiichiYaku(ctx) {
    if (!ctx.wriichi) {
      return false
    }
    if (ctx.menzen) {
      throw '必须在门清状态下双立直'
    }
    if (ctx.riichi) {
      throw '无法与立直同时生效'
    }

    return true
  }

  function checkHaiteiYaku(ctx) {
    if (!ctx.haitei) {
      return false
    }
    if (!ctx.tsumo) {
      throw '海底必须自摸'
    }
    return true
  }

  function checkHoteiYaku(ctx) {
    if (!ctx.hotei) {
      return false
    }
    if (ctx.tsumo) {
      throw '河底无法自摸'
    }
    if (ctx.ippatsu) {
      throw '河底无法复合一发'
    }
    return true
  }

  function checkChankanYaku(ctx) {
    if (!ctx.chankan) {
      return false
    }
    if (ctx.tsumo) {
      throw '抢杠无法自摸'
    }
    return true
  }

  function checkGokushiYaku(ctx) {
    if (ctx.fuuro.length > 0) {
      return false
    }
    var set = new Set()
    for (let card of ctx.tehai) {
      if (!Is19(card) && !IsCharacterCard(card)) {
        return false
      }
      set.add(card.score)
    }
    if (set.size() != 12) {
      return false
    }
    var agariCard = ctx.agariCard
    return (
      (Is19(agariCard) || IsCharacterCard(agariCard)) &&
      !set.has(agariCard.score)
    )
  }

  function checkGokushiJusanmachiYaku(ctx) {
    if (ctx.fuuro.length > 0) {
      return false
    }
    var set = new Set()
    for (let card of ctx.tehai) {
      if (!Is19(card) && !IsCharacterCard(card)) {
        return false
      }
      set.add(card.score)
    }
    if (set.size() != 13) {
      return false
    }
    var agariCard = ctx.agariCard
    return Is19(agariCard) || IsCharacterCard(agariCard)
  }

  function checkGokushiJusanmachiYakuWithTenho(ctx) {
    return (
      checkGokushiJusanmachiYaku(ctx) ||
      (checkGokushiYaku(ctx) && ctx.tenho === true)
    )
  }
</script>
